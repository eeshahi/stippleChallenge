---
title: "Selection Bias & Missing Data Challenge - Part 1"
subtitle: "Blue Noise Stippling: Creating Art from Data"
format:
  html: default
execute:
  echo: false
  eval: true
---

```{r setup, include=FALSE}
# Setup chunk: Suppress the xfun::attr() deprecation warning
# This warning is harmless but can be annoying during rendering
# Individual code chunks can override these settings if needed
knitr::opts_chunk$set(
  warning = FALSE,  # Suppress warnings (including xfun deprecation)
  message = FALSE   # Suppress package loading messages
)
# Note: Chunks with explicit warning/message settings will override these defaults
```


## The Problem: Can Algorithms Create Art?

**Core Question:** How can we convert a photograph into an aesthetically pleasing pattern of dots that preserves the visual information of the original image?

**The Challenge:** Blue noise stippling is a technique that converts images into patterns of dots (stipples) using algorithms that balance visual accuracy with spatial distribution. This challenge asks you to implement a modified "void and cluster" algorithm that combines importance sampling with blue noise distribution properties to create stippling patterns that are both visually accurate and spatially well-distributed.

**Our Approach:** We'll use a modified void-and-cluster algorithm that:
1. Creates an importance map identifying visually important regions
2. Uses a toroidal (periodic) Gaussian kernel for repulsion to ensure blue noise properties
3. Iteratively selects points with minimum energy
4. Balances image content importance with blue noise spatial distribution



## Introduction to Blue Noise Stippling

Blue noise stippling is a technique for converting images into a pattern of dots (stipples) that preserves the visual information of the original image while creating an aesthetically pleasing, evenly distributed pattern. This method follows the approach described by [Bart Wronski](https://bartwronski.com/2022/08/31/progressive-image-stippling-and-greedy-blue-noise-importance-sampling/).

The method uses a modified "void and cluster" algorithm that combines importance sampling with blue noise distribution properties to create stippling patterns that are both visually accurate and spatially well-distributed. This version uses **smooth extreme downweighting** that selectively downweights very dark and very light tones while preserving mid-tones, creating a more balanced distribution of stipples across the image.

## Loading the Original Image

First, let's load an image that we'll convert to a blue noise stippling pattern. You can use any image you'd like, but we'll demonstrate with the provided example.

```{r}
#| label: load-image-r
#| echo: false
#| fig-cap: "Original image before stippling"
#| fig-width: 8
#| fig-height: 6
#| dpi: 300

library(magick)
library(ggplot2)

# Load the image
img_path <- 'cheeseburger2.png'
original_img <- image_read(img_path)

# Convert to grayscale
original_img <- image_convert(original_img, colorspace = "Gray")

# Get image dimensions
img_info <- image_info(original_img)
img_width <- img_info$width
img_height <- img_info$height

# Display the original image using image() function for consistent orientation
# Convert to matrix for display
img_array <- as.numeric(image_data(original_img, "gray")[1,,])
dim(img_array) <- c(img_width, img_height)
img_matrix_display <- t(img_array) / 255.0  # [height, width]
# Flip vertically to match R's coordinate system
img_matrix_display <- img_matrix_display[nrow(img_matrix_display):1, ]
par(mar = c(1, 1, 2, 1))
image(1:img_width, 1:img_height, t(img_matrix_display), 
      col = gray(seq(0, 1, length.out = 256)),
      xlab = "", ylab = "", axes = FALSE, main = "Original Image", 
      asp = img_height/img_width, ylim = c(img_height, 1))

cat("Image dimensions:", img_height, "x", img_width, "pixels\n")
```

## Importance Mapping

Before applying the stippling algorithm, we create an **importance map** that identifies which regions of the image should receive more stipples. The importance map is computed by:

- **Brightness inversion**: The image brightness is inverted so that dark areas receive higher importance and thus more dots, while light areas receive fewer dots
- **Extreme tone downweighting**: Smooth Gaussian functions downweight tones below 0.2 (very dark) and above 0.8 (very light), creating a gradual transition that preserves mid-tones
- **Mid-tone boost**: A smooth Gaussian function centered on mid-tones provides a gradual increase in importance for mid-tone regions, ensuring they receive appropriate stippling density
- **Selective and effective**: This approach ensures that stipples are distributed appropriately (more dots in dark areas and mid-tones, fewer in extreme dark/light areas) while maintaining good spatial distribution

```{r}
#| label: importance-map-r
#| echo: false
#| message: false
#| warning: false

compute_importance <- function(gray_img, 
                                extreme_downweight = 0.5,
                                extreme_threshold_low = 0.4,
                                extreme_threshold_high = 0.8,
                                extreme_sigma = 0.1,
                                mid_tone_boost = 0.4,
                                mid_tone_sigma = 0.2) {
  # Clip image to [0, 1]
  I <- pmax(pmin(gray_img, 1.0), 0.0)
  
  # Invert brightness
  I_inverted <- 1.0 - I
  
  # Dark mask
... (380 lines left)